#include "world_factory.h"

#define dbg(x) dout((DebugLevel)(x),D_GAME) << __FILE__ << ":" << __LINE__ << ": "
// single static instance of the world generator
world_factory *world_generator;

typedef int (world_factory::*worldgen_display)(WINDOW *, WORLD *);

/**
 * Returns whether or not the given (ASCII) character is usable in a (player)
 * character's name. Only printable symbols not reserved by the filesystem are
 * permitted.
 * @param ch The char to check.
 * @return true if the char is allowed in a name, false if not.
 */

bool char_allowed(char ch)
{
    //Allow everything EXCEPT the following reserved characters:
    return (ch > 31 //0-31 are control characters
         && ch < 127 //DEL character
         && ch != '/' && ch != '\\' //Path separators
         && ch != '?' && ch != '*' && ch != '%' //Wildcards
         && ch != ':' //Mount point/drive marker
         && ch != '|' //Output pipe
         && ch != '"' //Filename (with spaces) marker
         && ch != '>' && ch != '<'); //Input/output redirection
}

std::string world_options_header()
{
    return "\
# This file is autogenerated from the values picked during World Gen, and\n\
# should not be altered in any way once the world is generated. If you want\n\
# to edit it, you will need to generate a new world.\n\
\n\
";
}

world_factory::world_factory()
{
    //ctor
    active_world = NULL;
}

world_factory::~world_factory()
{
    //dtor
    if (active_world)
    {
        delete active_world;
    }
}

WORLD *world_factory::make_new_world()
{
    // Window variables
    const int iOffsetX = (TERMX > FULL_SCREEN_WIDTH) ? (TERMX-FULL_SCREEN_WIDTH)/2 : 0;
    const int iOffsetY = (TERMY > FULL_SCREEN_HEIGHT) ? (TERMY-FULL_SCREEN_HEIGHT)/2 : 0;

    // world to return after generating!
    WORLD *retworld = new WORLD();

    // set up windows!
    WINDOW *wf_win = newwin(FULL_SCREEN_HEIGHT, FULL_SCREEN_WIDTH, iOffsetY, iOffsetX);

    // prepare tab display order
    std::vector<worldgen_display> tabs;

    tabs.push_back(&world_factory::show_worldgen_tab_options);
    tabs.push_back(&world_factory::show_worldgen_tab_confirm);

    int curtab = 0;
    const int numtabs = tabs.size();

    while (curtab >= 0 && curtab < numtabs)
    {
        curtab += (world_generator->*tabs[curtab])(wf_win, retworld);

        if (curtab < 0)
        {
            if (!query_yn(_("Do you want to abort World Generation?")))
            {
                curtab = 0;
            }
        }
    }

    if (curtab < 0)
    {
        return NULL;
    }

    save_world(retworld);

    return retworld;
}

WORLD *world_factory::load_world(std::string world_name, bool setactive)
{
    return NULL;
}

void world_factory::set_active_world(WORLD* world)
{
    world_generator->active_world = world;
}

std::map<std::string, WORLD*> world_factory::get_all_worlds()
{
    std::map<std::string, WORLD*> retworlds;

    const std::string save_dir = "save";
    const std::string save_ext = ".sav";

    struct dirent *dp, *sdp;
    struct stat _buff;
    DIR *save = opendir(save_dir.c_str()), *world;

    if (!save)
    {
        #if (defined _WIN32 || defined __WIN32__)
            mkdir(save_dir.c_str());
        #else
            mkdir(save_dir.c_str(), 0777);
        #endif
        save = opendir(save_dir.c_str());
    }

    if (!save) {
        dbg(D_ERROR) << "game:opening_screen: Unable to make save directory.";
        debugmsg("Could not make './save' directory");
        endwin();
        exit(1);
    }

    // read through save directory looking for folders. These folders are the World folders containing the save data
    while ((dp = readdir(save)))
    {
        if (stat(dp->d_name, &_buff) != 0x4)
        {
            //DebugLog() << "Potential Folder Found: "<< dp->d_name << "\n";
            // ignore "." and ".."
            if ((strcmp(dp->d_name, ".") != 0) && (strcmp(dp->d_name, "..") != 0))
            {
                std::string subdirname = save_dir + "/" + dp->d_name;
                //subdirname.append(dp->d_name);
                // now that we have the world directory found and saved, we need to populate it with appropriate save file information
                world = opendir(subdirname.c_str());
                if (world == NULL)
                {
                    //DebugLog() << "Could not open directory: "<< dp->d_name << "\n";
                    continue;
                }
                else
                {
                    //worldlist.push_back(dp->d_name);
                    retworlds[dp->d_name] = new WORLD();
                    retworlds[dp->d_name]->world_name = dp->d_name;
                }
                while ((sdp = readdir(world)))
                {
                    std::string tmp = sdp->d_name;
                    if (tmp.find(".sav") != std::string::npos)
                    {
                        //world_savegames[dp->d_name].push_back(tmp.substr(0, tmp.find(".sav")));
                        retworlds[dp->d_name]->world_saves.push_back(tmp.substr(0,tmp.find(save_ext.c_str())));
                    }
                }
                closedir(world);
                retworlds[dp->d_name]->world_options = get_world_options(subdirname);
                // close the world directory
            }
        }
    }

    return retworlds;
}

std::map<std::string, cOpt> world_factory::get_world_options(std::string path)
{
    std::map<std::string, cOpt> retoptions;
    const std::string worldop_fname = "/worldoptions.txt";

    std::ifstream fin;
    std::stringstream worldopfile;

    worldopfile << path << worldop_fname;
    fin.open(worldopfile.str().c_str());

    if(!fin.is_open()) {
        fin.close();
        save_options();
        fin.open(worldopfile.str().c_str());
        if(!fin.is_open()) {
            DebugLog() << "Could neither read nor create world options file\n";
            return retoptions;
        }
    }
    std::string sLine;

    while (!fin.eof())
    {
        getline(fin, sLine);

        if (sLine != "" && sLine[0] != '#' && std::count(sLine.begin(), sLine.end(), ' ') == 1)
        {
            int ipos = sLine.find(' ');
            retoptions[sLine.substr(0, ipos)].setValue(sLine.substr(ipos+1, sLine.length()));
        }
    }

    fin.close();

    return retoptions;
}

void world_factory::save_world(WORLD *world)
{
    // if world arg == NULL then change it to the active_world
    if (!world)
    {
        world = active_world;
    }
    // if the active world == NULL then return w/o saving
    if (!world)
    {
        return;
    }

    std::ofstream fout;
    std::stringstream woption;
    woption << "save/" << world->world_name << "/worldoptions.txt";
    fout.open(woption.str().c_str());

    if (!fout.is_open())
    {
        return;
    }
    fout << world_options_header() << std::endl;

    for (std::map<std::string, cOpt>::iterator it = world->world_options.begin(); it != world->world_options.end(); ++it)
    {
        fout << "#" << it->second.getTooltip() << std::endl;
        fout << "#Default: " << it->second.getDefaultText() << std::endl;
        fout << it->first << " " << it->second.getValue() << std::endl << std::endl;
    }

    fout.close();
}

// UI Functions
int world_factory::show_worldgen_tab_options(WINDOW *win, WORLD* world)
{
    const int iTooltipHeight = 3;
    const int iContentHeight = FULL_SCREEN_HEIGHT-3-iTooltipHeight;

    const int iOffsetX = (TERMX > FULL_SCREEN_WIDTH) ? (TERMX-FULL_SCREEN_WIDTH)/2 : 0;
    const int iOffsetY = (TERMY > FULL_SCREEN_HEIGHT) ? (TERMY-FULL_SCREEN_HEIGHT)/2 : 0;

    WINDOW* w_options = newwin(iContentHeight, FULL_SCREEN_WIDTH - 2, iTooltipHeight + 2 + iOffsetY, 1 + iOffsetX);

    std::stringstream sTemp;

    std::map<int, bool> mapLines;
    mapLines[3] = true;
    mapLines[60] = true;

    // only populate once
    if (world->world_options.size() == 0)
    {
        for (std::map<std::string, cOpt>::iterator it = OPTIONS.begin(); it != OPTIONS.end(); ++it)
        {
            if (it->second.getPage() == "world_default")
            {
                world->world_options[it->first] = it->second;
            }
        }
    }

    std::vector<std::string> keys;
    for (std::map<std::string, cOpt>::iterator it = world->world_options.begin(); it != world->world_options.end(); ++it)
    {
        keys.push_back(it->first);
    }

    draw_tabs(win, 0, _("World Gen Options"), _("Confirmation"));

    wrefresh(win);
    refresh();

    char ch=' ';
    int sel=0;

    int numoptions = world->world_options.size();
    int curoption=0;
    do
    {
        curoption = 0;
        for (std::map<std::string, cOpt>::iterator it = world->world_options.begin(); it != world->world_options.end(); ++it)
        {
            nc_color cLineColor = c_ltgreen;

            sTemp.str("");
            sTemp << curoption + 1;
            mvwprintz(w_options, curoption , 0, c_white, sTemp.str().c_str());
            mvwprintz(w_options, curoption , 4, c_white, "");

            if (sel == curoption) {
                wprintz(w_options, c_yellow, ">> ");
            } else {
                wprintz(w_options, c_yellow, "   ");
            }

            wprintz(w_options, c_white, "%s", (it->second.getMenuText()).c_str());

            if (it->second.getValue() == "False") {
                cLineColor = c_ltred;
            }

            mvwprintz(w_options, curoption, 62, (sel == curoption) ? hilite(cLineColor) : cLineColor, "%s", (it->second.getValue()).c_str());
            //mvwprintz(win, 4, 2, c_white, )
            ++curoption;
        }

        wrefresh(w_options);

        ch = input();
        if (world->world_options.size() > 0 || ch == '\t')
        {
            switch(ch) {
                case 'j': //move down
                    sel++;
                    if (sel >= world->world_options.size()) {
                        sel = 0;
                    }
                    break;
                case 'k': //move up
                    sel--;
                    if (sel < 0) {
                        sel = world->world_options.size()-1;
                    }
                    break;
                case 'l': //set to prev value
                    world->world_options[keys[sel]].setNext();
                    //bStuffChanged = true;
                    break;
                case 'h': //set to next value
                    world->world_options[keys[sel]].setPrev();
                    //bStuffChanged = true;
                    break;

                case '<':
                    return -1;
                    break;
                case '>':
                    return 1;
                    break;
            }
        }
    }while (true);

    return 0;
}

int world_factory::show_worldgen_tab_confirm(WINDOW *win, WORLD* world)
{
    draw_tabs(win, 1, _("World Gen Options"), _("Confirmation"));

    unsigned namebar_pos = 3 + utf8_width(_("World Name:"));
    mvwprintz(win, 6, 2, c_ltgray, _("World Name:"));
    mvwprintz(win, 6, namebar_pos, c_ltgray, "______________________________");

    fold_and_print(win, 10, 2, 76, c_ltgray,
                _("When you are satisfied with the world as it is and are ready to continue, press >"));
    fold_and_print(win, 12, 2, 76, c_ltgray, _("To go back and review your world, press <"));
    fold_and_print(win, 14, 2, 76, c_green, _("To pick a random name for your world, press ?."));

    int line = 1;
    bool noname = false, loop = true;
    long ch;

    std::string worldname = "";

    do
    {
        if (!noname)
        {
            mvwprintz(win, 6, 8, c_ltgray, "%s", worldname.c_str());
            if (line == 1)
            {
                wprintz(win, h_ltgray, "_");
            }
        }

        wrefresh(win);
        ch = input();
        if (noname) {
            mvwprintz(win, 6, namebar_pos, c_ltgray, "______________________________");
            noname = false;
        }


        if (ch == '>')
        {
            if (worldname.size() == 0)
            {
                mvwprintz(win, 6, namebar_pos, h_ltgray, _("______NO NAME ENTERED!!!!_____"));
                noname = true;
                wrefresh(win);
                if (!query_yn(_("Are you SURE you're finished? Your name will be randomly generated.")))
                {
                    continue;
                }
                else
                {
                    world->world_name = pick_random_name();
                    return 1;
                }
            }
            else if (query_yn(_("Are you SURE you're finished?")))
            {
                world->world_name = worldname;
                return 1;
            }
            else
            {
                continue;
            }
        }
        else if (ch == '<')
        {
            world->world_name = worldname;
            return -1;
        }
        else if (ch == '?')
        {
            mvwprintz(win, 6, namebar_pos, c_ltgray, "______________________________");
            world->world_name = worldname = pick_random_name();
        }
        else
        {
            switch (line) {
                case 1:
                    if (ch == KEY_BACKSPACE || ch == 127)
                    {
                        if (worldname.size() > 0)
                        {
                            //erease utf8 character TODO: make a function
                            while(worldname.size()>0 && ((unsigned char)worldname[worldname.size()-1])>=128 &&
                                                        ((unsigned char)worldname[(int)worldname.size()-1])<=191)
                            {
                                worldname.erase(worldname.size()-1);
                            }
                            worldname.erase(worldname.size()-1);
                            mvwprintz(win, 6, namebar_pos, c_ltgray, "______________________________");
                            mvwprintz(win, 6, namebar_pos, c_ltgray, "%s", worldname.c_str());
                            wprintz(win, h_ltgray, "_");
                        }
                    }
                    else if (char_allowed(ch) &&  utf8_width(worldname.c_str()) < 30)
                    {
                        worldname.push_back(ch);
                    }
                    else if(ch==KEY_F(2))
                    {
                        std::string tmp = get_input_string_from_file();
                        int tmplen = utf8_width(tmp.c_str());
                        if(tmplen>0 && tmplen+utf8_width(worldname.c_str())<30)
                        {
                            worldname.append(tmp);
                        }
                    }
                    //experimental unicode input
                    else if(ch>127)
                    {
                        std::string tmp = utf32_to_utf8(ch);
                        int tmplen = utf8_width(tmp.c_str());
                        if(tmplen>0 && tmplen+utf8_width(worldname.c_str())<30)
                        {
                            worldname.append(tmp);
                        }
                    }
                    break;
            }
        }
    }while (true);

    return 0;
}

std::string world_factory::pick_random_name()
{
    return "WOOT";
}
